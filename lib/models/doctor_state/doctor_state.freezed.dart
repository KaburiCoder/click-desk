// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'doctor_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

DoctorState _$DoctorStateFromJson(Map<String, dynamic> json) {
  return _DoctorState.fromJson(json);
}

/// @nodoc
mixin _$DoctorState {
  String get id => throw _privateConstructorUsedError;
  String get userId => throw _privateConstructorUsedError;
  int get seq => throw _privateConstructorUsedError;
  String get code => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get jinchalName => throw _privateConstructorUsedError;
  String get kwamokName => throw _privateConstructorUsedError;
  int get waitingPatientsCount => throw _privateConstructorUsedError;
  bool get gumjin => throw _privateConstructorUsedError;
  DoctorWorks get works => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DoctorStateCopyWith<DoctorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DoctorStateCopyWith<$Res> {
  factory $DoctorStateCopyWith(
          DoctorState value, $Res Function(DoctorState) then) =
      _$DoctorStateCopyWithImpl<$Res, DoctorState>;
  @useResult
  $Res call(
      {String id,
      String userId,
      int seq,
      String code,
      String name,
      String jinchalName,
      String kwamokName,
      int waitingPatientsCount,
      bool gumjin,
      DoctorWorks works});

  $DoctorWorksCopyWith<$Res> get works;
}

/// @nodoc
class _$DoctorStateCopyWithImpl<$Res, $Val extends DoctorState>
    implements $DoctorStateCopyWith<$Res> {
  _$DoctorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? seq = null,
    Object? code = null,
    Object? name = null,
    Object? jinchalName = null,
    Object? kwamokName = null,
    Object? waitingPatientsCount = null,
    Object? gumjin = null,
    Object? works = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      seq: null == seq
          ? _value.seq
          : seq // ignore: cast_nullable_to_non_nullable
              as int,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      jinchalName: null == jinchalName
          ? _value.jinchalName
          : jinchalName // ignore: cast_nullable_to_non_nullable
              as String,
      kwamokName: null == kwamokName
          ? _value.kwamokName
          : kwamokName // ignore: cast_nullable_to_non_nullable
              as String,
      waitingPatientsCount: null == waitingPatientsCount
          ? _value.waitingPatientsCount
          : waitingPatientsCount // ignore: cast_nullable_to_non_nullable
              as int,
      gumjin: null == gumjin
          ? _value.gumjin
          : gumjin // ignore: cast_nullable_to_non_nullable
              as bool,
      works: null == works
          ? _value.works
          : works // ignore: cast_nullable_to_non_nullable
              as DoctorWorks,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $DoctorWorksCopyWith<$Res> get works {
    return $DoctorWorksCopyWith<$Res>(_value.works, (value) {
      return _then(_value.copyWith(works: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$DoctorStateImplCopyWith<$Res>
    implements $DoctorStateCopyWith<$Res> {
  factory _$$DoctorStateImplCopyWith(
          _$DoctorStateImpl value, $Res Function(_$DoctorStateImpl) then) =
      __$$DoctorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String userId,
      int seq,
      String code,
      String name,
      String jinchalName,
      String kwamokName,
      int waitingPatientsCount,
      bool gumjin,
      DoctorWorks works});

  @override
  $DoctorWorksCopyWith<$Res> get works;
}

/// @nodoc
class __$$DoctorStateImplCopyWithImpl<$Res>
    extends _$DoctorStateCopyWithImpl<$Res, _$DoctorStateImpl>
    implements _$$DoctorStateImplCopyWith<$Res> {
  __$$DoctorStateImplCopyWithImpl(
      _$DoctorStateImpl _value, $Res Function(_$DoctorStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? seq = null,
    Object? code = null,
    Object? name = null,
    Object? jinchalName = null,
    Object? kwamokName = null,
    Object? waitingPatientsCount = null,
    Object? gumjin = null,
    Object? works = null,
  }) {
    return _then(_$DoctorStateImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      seq: null == seq
          ? _value.seq
          : seq // ignore: cast_nullable_to_non_nullable
              as int,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      jinchalName: null == jinchalName
          ? _value.jinchalName
          : jinchalName // ignore: cast_nullable_to_non_nullable
              as String,
      kwamokName: null == kwamokName
          ? _value.kwamokName
          : kwamokName // ignore: cast_nullable_to_non_nullable
              as String,
      waitingPatientsCount: null == waitingPatientsCount
          ? _value.waitingPatientsCount
          : waitingPatientsCount // ignore: cast_nullable_to_non_nullable
              as int,
      gumjin: null == gumjin
          ? _value.gumjin
          : gumjin // ignore: cast_nullable_to_non_nullable
              as bool,
      works: null == works
          ? _value.works
          : works // ignore: cast_nullable_to_non_nullable
              as DoctorWorks,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DoctorStateImpl extends _DoctorState {
  const _$DoctorStateImpl(
      {this.id = "",
      this.userId = "",
      this.seq = 0,
      this.code = "",
      this.name = "",
      this.jinchalName = "",
      this.kwamokName = "",
      this.waitingPatientsCount = 0,
      this.gumjin = false,
      this.works = const DoctorWorks()})
      : super._();

  factory _$DoctorStateImpl.fromJson(Map<String, dynamic> json) =>
      _$$DoctorStateImplFromJson(json);

  @override
  @JsonKey()
  final String id;
  @override
  @JsonKey()
  final String userId;
  @override
  @JsonKey()
  final int seq;
  @override
  @JsonKey()
  final String code;
  @override
  @JsonKey()
  final String name;
  @override
  @JsonKey()
  final String jinchalName;
  @override
  @JsonKey()
  final String kwamokName;
  @override
  @JsonKey()
  final int waitingPatientsCount;
  @override
  @JsonKey()
  final bool gumjin;
  @override
  @JsonKey()
  final DoctorWorks works;

  @override
  String toString() {
    return 'DoctorState(id: $id, userId: $userId, seq: $seq, code: $code, name: $name, jinchalName: $jinchalName, kwamokName: $kwamokName, waitingPatientsCount: $waitingPatientsCount, gumjin: $gumjin, works: $works)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DoctorStateImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.seq, seq) || other.seq == seq) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.jinchalName, jinchalName) ||
                other.jinchalName == jinchalName) &&
            (identical(other.kwamokName, kwamokName) ||
                other.kwamokName == kwamokName) &&
            (identical(other.waitingPatientsCount, waitingPatientsCount) ||
                other.waitingPatientsCount == waitingPatientsCount) &&
            (identical(other.gumjin, gumjin) || other.gumjin == gumjin) &&
            (identical(other.works, works) || other.works == works));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, userId, seq, code, name,
      jinchalName, kwamokName, waitingPatientsCount, gumjin, works);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DoctorStateImplCopyWith<_$DoctorStateImpl> get copyWith =>
      __$$DoctorStateImplCopyWithImpl<_$DoctorStateImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DoctorStateImplToJson(
      this,
    );
  }
}

abstract class _DoctorState extends DoctorState {
  const factory _DoctorState(
      {final String id,
      final String userId,
      final int seq,
      final String code,
      final String name,
      final String jinchalName,
      final String kwamokName,
      final int waitingPatientsCount,
      final bool gumjin,
      final DoctorWorks works}) = _$DoctorStateImpl;
  const _DoctorState._() : super._();

  factory _DoctorState.fromJson(Map<String, dynamic> json) =
      _$DoctorStateImpl.fromJson;

  @override
  String get id;
  @override
  String get userId;
  @override
  int get seq;
  @override
  String get code;
  @override
  String get name;
  @override
  String get jinchalName;
  @override
  String get kwamokName;
  @override
  int get waitingPatientsCount;
  @override
  bool get gumjin;
  @override
  DoctorWorks get works;
  @override
  @JsonKey(ignore: true)
  _$$DoctorStateImplCopyWith<_$DoctorStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

DoctorWorks _$DoctorWorksFromJson(Map<String, dynamic> json) {
  return _DoctorWorks.fromJson(json);
}

/// @nodoc
mixin _$DoctorWorks {
  List<TimeRange> get mon => throw _privateConstructorUsedError;
  List<TimeRange> get tue => throw _privateConstructorUsedError;
  List<TimeRange> get wed => throw _privateConstructorUsedError;
  List<TimeRange> get thu => throw _privateConstructorUsedError;
  List<TimeRange> get fri => throw _privateConstructorUsedError;
  List<TimeRange> get sat => throw _privateConstructorUsedError;
  List<TimeRange> get sun => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DoctorWorksCopyWith<DoctorWorks> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DoctorWorksCopyWith<$Res> {
  factory $DoctorWorksCopyWith(
          DoctorWorks value, $Res Function(DoctorWorks) then) =
      _$DoctorWorksCopyWithImpl<$Res, DoctorWorks>;
  @useResult
  $Res call(
      {List<TimeRange> mon,
      List<TimeRange> tue,
      List<TimeRange> wed,
      List<TimeRange> thu,
      List<TimeRange> fri,
      List<TimeRange> sat,
      List<TimeRange> sun});
}

/// @nodoc
class _$DoctorWorksCopyWithImpl<$Res, $Val extends DoctorWorks>
    implements $DoctorWorksCopyWith<$Res> {
  _$DoctorWorksCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mon = null,
    Object? tue = null,
    Object? wed = null,
    Object? thu = null,
    Object? fri = null,
    Object? sat = null,
    Object? sun = null,
  }) {
    return _then(_value.copyWith(
      mon: null == mon
          ? _value.mon
          : mon // ignore: cast_nullable_to_non_nullable
              as List<TimeRange>,
      tue: null == tue
          ? _value.tue
          : tue // ignore: cast_nullable_to_non_nullable
              as List<TimeRange>,
      wed: null == wed
          ? _value.wed
          : wed // ignore: cast_nullable_to_non_nullable
              as List<TimeRange>,
      thu: null == thu
          ? _value.thu
          : thu // ignore: cast_nullable_to_non_nullable
              as List<TimeRange>,
      fri: null == fri
          ? _value.fri
          : fri // ignore: cast_nullable_to_non_nullable
              as List<TimeRange>,
      sat: null == sat
          ? _value.sat
          : sat // ignore: cast_nullable_to_non_nullable
              as List<TimeRange>,
      sun: null == sun
          ? _value.sun
          : sun // ignore: cast_nullable_to_non_nullable
              as List<TimeRange>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DoctorWorksImplCopyWith<$Res>
    implements $DoctorWorksCopyWith<$Res> {
  factory _$$DoctorWorksImplCopyWith(
          _$DoctorWorksImpl value, $Res Function(_$DoctorWorksImpl) then) =
      __$$DoctorWorksImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<TimeRange> mon,
      List<TimeRange> tue,
      List<TimeRange> wed,
      List<TimeRange> thu,
      List<TimeRange> fri,
      List<TimeRange> sat,
      List<TimeRange> sun});
}

/// @nodoc
class __$$DoctorWorksImplCopyWithImpl<$Res>
    extends _$DoctorWorksCopyWithImpl<$Res, _$DoctorWorksImpl>
    implements _$$DoctorWorksImplCopyWith<$Res> {
  __$$DoctorWorksImplCopyWithImpl(
      _$DoctorWorksImpl _value, $Res Function(_$DoctorWorksImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mon = null,
    Object? tue = null,
    Object? wed = null,
    Object? thu = null,
    Object? fri = null,
    Object? sat = null,
    Object? sun = null,
  }) {
    return _then(_$DoctorWorksImpl(
      mon: null == mon
          ? _value._mon
          : mon // ignore: cast_nullable_to_non_nullable
              as List<TimeRange>,
      tue: null == tue
          ? _value._tue
          : tue // ignore: cast_nullable_to_non_nullable
              as List<TimeRange>,
      wed: null == wed
          ? _value._wed
          : wed // ignore: cast_nullable_to_non_nullable
              as List<TimeRange>,
      thu: null == thu
          ? _value._thu
          : thu // ignore: cast_nullable_to_non_nullable
              as List<TimeRange>,
      fri: null == fri
          ? _value._fri
          : fri // ignore: cast_nullable_to_non_nullable
              as List<TimeRange>,
      sat: null == sat
          ? _value._sat
          : sat // ignore: cast_nullable_to_non_nullable
              as List<TimeRange>,
      sun: null == sun
          ? _value._sun
          : sun // ignore: cast_nullable_to_non_nullable
              as List<TimeRange>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DoctorWorksImpl extends _DoctorWorks {
  const _$DoctorWorksImpl(
      {final List<TimeRange> mon = const [],
      final List<TimeRange> tue = const [],
      final List<TimeRange> wed = const [],
      final List<TimeRange> thu = const [],
      final List<TimeRange> fri = const [],
      final List<TimeRange> sat = const [],
      final List<TimeRange> sun = const []})
      : _mon = mon,
        _tue = tue,
        _wed = wed,
        _thu = thu,
        _fri = fri,
        _sat = sat,
        _sun = sun,
        super._();

  factory _$DoctorWorksImpl.fromJson(Map<String, dynamic> json) =>
      _$$DoctorWorksImplFromJson(json);

  final List<TimeRange> _mon;
  @override
  @JsonKey()
  List<TimeRange> get mon {
    if (_mon is EqualUnmodifiableListView) return _mon;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_mon);
  }

  final List<TimeRange> _tue;
  @override
  @JsonKey()
  List<TimeRange> get tue {
    if (_tue is EqualUnmodifiableListView) return _tue;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tue);
  }

  final List<TimeRange> _wed;
  @override
  @JsonKey()
  List<TimeRange> get wed {
    if (_wed is EqualUnmodifiableListView) return _wed;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_wed);
  }

  final List<TimeRange> _thu;
  @override
  @JsonKey()
  List<TimeRange> get thu {
    if (_thu is EqualUnmodifiableListView) return _thu;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_thu);
  }

  final List<TimeRange> _fri;
  @override
  @JsonKey()
  List<TimeRange> get fri {
    if (_fri is EqualUnmodifiableListView) return _fri;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_fri);
  }

  final List<TimeRange> _sat;
  @override
  @JsonKey()
  List<TimeRange> get sat {
    if (_sat is EqualUnmodifiableListView) return _sat;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_sat);
  }

  final List<TimeRange> _sun;
  @override
  @JsonKey()
  List<TimeRange> get sun {
    if (_sun is EqualUnmodifiableListView) return _sun;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_sun);
  }

  @override
  String toString() {
    return 'DoctorWorks(mon: $mon, tue: $tue, wed: $wed, thu: $thu, fri: $fri, sat: $sat, sun: $sun)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DoctorWorksImpl &&
            const DeepCollectionEquality().equals(other._mon, _mon) &&
            const DeepCollectionEquality().equals(other._tue, _tue) &&
            const DeepCollectionEquality().equals(other._wed, _wed) &&
            const DeepCollectionEquality().equals(other._thu, _thu) &&
            const DeepCollectionEquality().equals(other._fri, _fri) &&
            const DeepCollectionEquality().equals(other._sat, _sat) &&
            const DeepCollectionEquality().equals(other._sun, _sun));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_mon),
      const DeepCollectionEquality().hash(_tue),
      const DeepCollectionEquality().hash(_wed),
      const DeepCollectionEquality().hash(_thu),
      const DeepCollectionEquality().hash(_fri),
      const DeepCollectionEquality().hash(_sat),
      const DeepCollectionEquality().hash(_sun));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DoctorWorksImplCopyWith<_$DoctorWorksImpl> get copyWith =>
      __$$DoctorWorksImplCopyWithImpl<_$DoctorWorksImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DoctorWorksImplToJson(
      this,
    );
  }
}

abstract class _DoctorWorks extends DoctorWorks {
  const factory _DoctorWorks(
      {final List<TimeRange> mon,
      final List<TimeRange> tue,
      final List<TimeRange> wed,
      final List<TimeRange> thu,
      final List<TimeRange> fri,
      final List<TimeRange> sat,
      final List<TimeRange> sun}) = _$DoctorWorksImpl;
  const _DoctorWorks._() : super._();

  factory _DoctorWorks.fromJson(Map<String, dynamic> json) =
      _$DoctorWorksImpl.fromJson;

  @override
  List<TimeRange> get mon;
  @override
  List<TimeRange> get tue;
  @override
  List<TimeRange> get wed;
  @override
  List<TimeRange> get thu;
  @override
  List<TimeRange> get fri;
  @override
  List<TimeRange> get sat;
  @override
  List<TimeRange> get sun;
  @override
  @JsonKey(ignore: true)
  _$$DoctorWorksImplCopyWith<_$DoctorWorksImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

TimeRange _$TimeRangeFromJson(Map<String, dynamic> json) {
  return _TimeRange.fromJson(json);
}

/// @nodoc
mixin _$TimeRange {
  TimeValue get start => throw _privateConstructorUsedError;
  TimeValue get end => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TimeRangeCopyWith<TimeRange> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TimeRangeCopyWith<$Res> {
  factory $TimeRangeCopyWith(TimeRange value, $Res Function(TimeRange) then) =
      _$TimeRangeCopyWithImpl<$Res, TimeRange>;
  @useResult
  $Res call({TimeValue start, TimeValue end});

  $TimeValueCopyWith<$Res> get start;
  $TimeValueCopyWith<$Res> get end;
}

/// @nodoc
class _$TimeRangeCopyWithImpl<$Res, $Val extends TimeRange>
    implements $TimeRangeCopyWith<$Res> {
  _$TimeRangeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? start = null,
    Object? end = null,
  }) {
    return _then(_value.copyWith(
      start: null == start
          ? _value.start
          : start // ignore: cast_nullable_to_non_nullable
              as TimeValue,
      end: null == end
          ? _value.end
          : end // ignore: cast_nullable_to_non_nullable
              as TimeValue,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $TimeValueCopyWith<$Res> get start {
    return $TimeValueCopyWith<$Res>(_value.start, (value) {
      return _then(_value.copyWith(start: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TimeValueCopyWith<$Res> get end {
    return $TimeValueCopyWith<$Res>(_value.end, (value) {
      return _then(_value.copyWith(end: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$TimeRangeImplCopyWith<$Res>
    implements $TimeRangeCopyWith<$Res> {
  factory _$$TimeRangeImplCopyWith(
          _$TimeRangeImpl value, $Res Function(_$TimeRangeImpl) then) =
      __$$TimeRangeImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({TimeValue start, TimeValue end});

  @override
  $TimeValueCopyWith<$Res> get start;
  @override
  $TimeValueCopyWith<$Res> get end;
}

/// @nodoc
class __$$TimeRangeImplCopyWithImpl<$Res>
    extends _$TimeRangeCopyWithImpl<$Res, _$TimeRangeImpl>
    implements _$$TimeRangeImplCopyWith<$Res> {
  __$$TimeRangeImplCopyWithImpl(
      _$TimeRangeImpl _value, $Res Function(_$TimeRangeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? start = null,
    Object? end = null,
  }) {
    return _then(_$TimeRangeImpl(
      start: null == start
          ? _value.start
          : start // ignore: cast_nullable_to_non_nullable
              as TimeValue,
      end: null == end
          ? _value.end
          : end // ignore: cast_nullable_to_non_nullable
              as TimeValue,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TimeRangeImpl implements _TimeRange {
  const _$TimeRangeImpl({required this.start, required this.end});

  factory _$TimeRangeImpl.fromJson(Map<String, dynamic> json) =>
      _$$TimeRangeImplFromJson(json);

  @override
  final TimeValue start;
  @override
  final TimeValue end;

  @override
  String toString() {
    return 'TimeRange(start: $start, end: $end)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TimeRangeImpl &&
            (identical(other.start, start) || other.start == start) &&
            (identical(other.end, end) || other.end == end));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, start, end);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TimeRangeImplCopyWith<_$TimeRangeImpl> get copyWith =>
      __$$TimeRangeImplCopyWithImpl<_$TimeRangeImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TimeRangeImplToJson(
      this,
    );
  }
}

abstract class _TimeRange implements TimeRange {
  const factory _TimeRange(
      {required final TimeValue start,
      required final TimeValue end}) = _$TimeRangeImpl;

  factory _TimeRange.fromJson(Map<String, dynamic> json) =
      _$TimeRangeImpl.fromJson;

  @override
  TimeValue get start;
  @override
  TimeValue get end;
  @override
  @JsonKey(ignore: true)
  _$$TimeRangeImplCopyWith<_$TimeRangeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

TimeValue _$TimeValueFromJson(Map<String, dynamic> json) {
  return _TimeValue.fromJson(json);
}

/// @nodoc
mixin _$TimeValue {
  int get hour => throw _privateConstructorUsedError;
  int get minute => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TimeValueCopyWith<TimeValue> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TimeValueCopyWith<$Res> {
  factory $TimeValueCopyWith(TimeValue value, $Res Function(TimeValue) then) =
      _$TimeValueCopyWithImpl<$Res, TimeValue>;
  @useResult
  $Res call({int hour, int minute});
}

/// @nodoc
class _$TimeValueCopyWithImpl<$Res, $Val extends TimeValue>
    implements $TimeValueCopyWith<$Res> {
  _$TimeValueCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hour = null,
    Object? minute = null,
  }) {
    return _then(_value.copyWith(
      hour: null == hour
          ? _value.hour
          : hour // ignore: cast_nullable_to_non_nullable
              as int,
      minute: null == minute
          ? _value.minute
          : minute // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TimeValueImplCopyWith<$Res>
    implements $TimeValueCopyWith<$Res> {
  factory _$$TimeValueImplCopyWith(
          _$TimeValueImpl value, $Res Function(_$TimeValueImpl) then) =
      __$$TimeValueImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int hour, int minute});
}

/// @nodoc
class __$$TimeValueImplCopyWithImpl<$Res>
    extends _$TimeValueCopyWithImpl<$Res, _$TimeValueImpl>
    implements _$$TimeValueImplCopyWith<$Res> {
  __$$TimeValueImplCopyWithImpl(
      _$TimeValueImpl _value, $Res Function(_$TimeValueImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hour = null,
    Object? minute = null,
  }) {
    return _then(_$TimeValueImpl(
      hour: null == hour
          ? _value.hour
          : hour // ignore: cast_nullable_to_non_nullable
              as int,
      minute: null == minute
          ? _value.minute
          : minute // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TimeValueImpl implements _TimeValue {
  const _$TimeValueImpl({required this.hour, required this.minute});

  factory _$TimeValueImpl.fromJson(Map<String, dynamic> json) =>
      _$$TimeValueImplFromJson(json);

  @override
  final int hour;
  @override
  final int minute;

  @override
  String toString() {
    return 'TimeValue(hour: $hour, minute: $minute)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TimeValueImpl &&
            (identical(other.hour, hour) || other.hour == hour) &&
            (identical(other.minute, minute) || other.minute == minute));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, hour, minute);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TimeValueImplCopyWith<_$TimeValueImpl> get copyWith =>
      __$$TimeValueImplCopyWithImpl<_$TimeValueImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TimeValueImplToJson(
      this,
    );
  }
}

abstract class _TimeValue implements TimeValue {
  const factory _TimeValue(
      {required final int hour, required final int minute}) = _$TimeValueImpl;

  factory _TimeValue.fromJson(Map<String, dynamic> json) =
      _$TimeValueImpl.fromJson;

  @override
  int get hour;
  @override
  int get minute;
  @override
  @JsonKey(ignore: true)
  _$$TimeValueImplCopyWith<_$TimeValueImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
